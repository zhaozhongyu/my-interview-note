## 我的总结
0. 非函数的原型链继承使用__proto__, 函数的原型链继承使用prototype查找.
1. prototype继承跟java的继承不同, 只会继承实例属性和方法.
2. 想要继承父类的静态属性或方法, 可以将子类的原型指向父类的实例, 或者指向父类的原型复制. 但这里的缺点是, 要先修改指向, 再去更新属性方法.
3. 对于某些JavaScript内建对象（如Date），如果实例对象不是由它本身的构造函数生成的，不能访问其内部的属性和方法. 也就是说, 需要更绕的方法继承(颠倒父子类, 将子类的方法连接到父类实例上, 实现变相的继承)
    1. 用父类构造函数创建实例
    2. 将实例的__proto__属性指向子类的原型对象
    3. 将子类原型对象的__proto__指向父类的原型对象


### 原型总结
1. 构造函数特点：
1.构造函数有原型对象prototype。
2.构造函数原型对象prototype里面有constructor，指向构造函数本身。
3.构造函数可以通过原型对象添加方法。
4.构造函数创建的实例对象有__proto__原型，指向构造函数的原型对象。
类：
1.class本质还是function
2.类的所有方法都定义在类的prototype属性上
3.类创建的实例，里面也有__proto__指向类的prototype原型对象
4.新的class写法，只是让对象原型的写法更加清晰，更像面向对象编程的语法而已。
5.ES6的类其实就是语法糖。

### 原型共享不会共享原型上的静态方法/属性.

```
继承属性，利用call改变this指向。但该方法只可以继承属性，实例不可以使用父类的方法。
    function Father(name) {
        this.name = name;
    }
    Father.prototype.dance = function () {
      console.log('I am dancing');
    };
    function Son(name, age) {
        Father.call(this, name);
        this.age = age;
    }
    let son = new Son('小红', 100);
    son.dance();   //报错
```
解决方法2：子类的原型指向父类的实例，这样就可以顺着原型链共享父类的方法了。并且为子类添加原型方法的时候，不会影响父类。
```
Son.prototype = Object.create(Father.prototype); 
// 或者

```