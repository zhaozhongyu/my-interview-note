### 遇到的难题?
1. 内核修改为加密asar
    过程中一共分了几步
    1. 先查找了对应的文档和github, 最后在issues里面找到了对应的回答, 回答上指出了关键的文件入口: `Archive.cc`和`asar.js`, 其中`archive.cc`的作用是读取并解析asar文件头, 以做进一步处理. asar.js则是对于asar文件的读写做fs的封装, 支持使用fs读取文件
    2. 考虑到性能的要求, 在js/css等文件加解密中, 不能选择非对称加密, 否则解密时间对客户端来说无法接受. 其次, 考虑到安全性要求, 最好不能是写死一个固定的aeskey, 在header的加密中, 可以允许使用非对称加密, 成本可以接受.
    3. 第一步, 因为一时没能找到在archive.cc中的合适解密方式, 所以换了一个思路, 只进行js文件的加解密, 然后header中增加一个用rsa解密的校验字段, 同时存放加密后的aeskey, 在asar.js对于fs封装解密方法. 在加载时使用executeJavaScript方法来执行. 并且, 在读取header时, 需要对header整体进行md5校验, 校验不通过的就退出进程.
    4. 第二步, 完成在archive.cc中的解密, 自此可以把整个header用aes-128-cbc加密, 在使用时, 先把aeskey用rsa解密出来, 然后对header做对应md5校验, 校验通过后, 解密整个header, 并进入加载文件流程
    5. 第三步, 完成对html/css等的加解密, 由于没有找到内核对整个文件的加载入口, 因此没有办法直接对整个文件进行解密, 但是我找到了data_reader读取磁盘的位置, 而且我发现它有一个特点, 它在第一次读取的时候, 会读取1024字节作为头判断, 在随后的每一次读取, 都会是读取65536字节大小, 直至读取到文件尾部. 然后, 就有一个新的方法, 我们知道aes-128-cbc方式是每隔16字节进行一次加密, 但前后有关, 因此使用这个方式会在第二次读取时出现解密错误的情况, 但是如果使用aes-128-ecb方式的话, 就可以对整个文件进行分段的加解密, 从而达到了可以加解密整个文件的目的. 对于某些文件大小不是16的整数倍的文件, 通过在文件尾部补空格的方式令大小达到16的整数倍.
    6. 最后还有一些别的处理, 比如说怎么存储rsa公钥, 按什么顺序进行解密等等. 这个就不展开说了.
2. imgViewer支持加载超大图片而不崩溃, 并且流畅预览
    1. 先确定了在内核端直接修改支持工作量过大, 得不偿失. 其次确定了可以通过canvas的drawImage方法进行裁剪图片操作.
    2. 然后做出了第一个版本, 在写死canvas大小的情况下, 根据鼠标拖动的movementX和movementY轴, 计算所得到的的宽高, 转换为图片大小后, 得出要画的图片x,y,宽高, 这里要处理的还有一些放大缩小时的边界值.
    3. 这时候已经可以支持超大图片不崩溃了, 但是测试时发现, 不管放大缩小到什么程度, 在拖动时基本上渲染延迟需要差不多2s. 然后采取了进一步的思路, 在初始化时, 将图片按`3000*3000`的大小分割成多张图片, 这里3000的选择是因为市面上大多数的图片大小都是2000分辨率左右, 设置为3000对大多数的图片都不需要触发, 同时`3000*3000`的图片在自测时看到渲染的延迟不高于1ms, 然后在分割成多张之后, 此时拖动或者放大缩小时, 需要在计算出整个图片的x,y宽高之后, 分张将小图片渲染出来, 在这里有一个小问题是在计算小图片渲染的宽高时, 需要用Math.ceil方法, 不然在四舍五入的时候有概率出现渲染的图片中间有一像素的白线. 
    4. 这个方法也有一个问题无法解决, 就是因为要分割图片, 所以初始化的时间比前一个方法要慢一些.
    5. 用figma导出的图片, 如果是10倍图的话, chrome有时候就直接打不开了.


3. 富文本编辑的问题, 比如删除时如何保留原有格式, 编辑/换行/设定格式时如何保留格式.
    

3. vue watch 错误触发的问题


### electron客户端和前端的区别
1. 客户端的三大块: 功能, 性能, 稳定性, 在我们客户端的开发中, 性能/稳定性是我们很关注的点, 但同时, 因为是本地文件加载, 所以不会遇到类似跨域这些网络请求的问题. 同样的, 
2. pc客户端关注的兼容性, 一般是指win7/win10的兼容性, 以及用户环境上的屏幕分辨率, 双屏/多屏, 多屏多dpi这些的兼容性, 还有的就是多个窗口的消息同步. 而这些在前端来说就不太需要关心, 前端更关心的应该是不同浏览器的兼容性, 同样也不会有多个窗口同步的问题.

