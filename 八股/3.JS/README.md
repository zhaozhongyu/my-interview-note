# 原型
-   **prototype** : js通过构造函数来创建对象，每个构造函数内部都会一个原型`prototype`属性，它指向另外一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。

-   **proto**: 当使用构造函数创建一个实例对象后，可以通过`__proto__`访问到`prototype`属性。

-   **constructor**：实例对象通过这个属性可以访问到构造函数

## 原型链
每个实例对象都有一个`__proto__`属性指向它的构造函数的原型对象，而这个原型对象也会有自己的原型对象，一层一层向上，直到顶级原型对象`null`，这样就形成了一个原型链。

当访问对象的一个属性或方法时，当对象身上不存在该属性方法时，就会沿着原型链向上查找，直到查找到该属性方法位置。

原型链的顶层原型是`Object.prototype`，如果这里没有就只指向`null`


### type和interface的区别
type和interface的相同点：都是用来定义对象或函数的形状, 它俩也支持继承,并且可以互相继承. 

type和interface的不同点
* type可以定义 基本类型的别名，如 type myString = string
* type可以通过 typeof 操作符来定义，如 type myType = typeof someObj
* type可以申明 联合类型，如 type unionType = myType1 | myType2
* type可以申明 元组类型，如 type yuanzu = [myType1, myType2]
* interface可以 声明合并，这种情况下，如果是type的话，就会报 重复定义 的警告

# 输入一个url到页面展示的过程

1. 输入地址，浏览器解析网址。
2. DNS解析，查询到IP，返回对应的IP。
3. TCP连接(TCP 三次握手 80 端口)。[https 在 TCP 连接之前 SSL/TLS 做了加密，防劫持，需要证书，端口不同 443]
4. 发送http请求。
5. 返回http响应。
6. 浏览器解析渲染页面。
7. 断开连接(四次挥手)。

## 数据类型
JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。

-   **堆：** 存放**引用数据类型**，引用数据类型占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；**引用数据类型在栈中存储了指针**，该指针指向堆中该实体的起始地址，如`Object`、`Array`、`Function`。

-   **栈：** 存放**原始数据类型**，栈中的简单数据段，占据空间小，属于被频繁使用的数据，如`String`、`Number`、`Null`、`Boolean`。

`Undefined` 和 `Null` 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 `undefined` 和 `null`。

-   **undefined** 代表的含义是**未定义**，一般变量**声明了但还没有定义**的时候会返回 `undefined`，`typeof`为`undefined`
-   **null** 代表的含义是**空对象**，null主要用于赋值给一些可能会返回对象的变量，作为初始化，`typeof`为`object`

## instanceof 运算符的实现原理及实现
`instanceof`运算符适用于检测构造函数的`prototype`属性上是否出现在某个实例对象的原型链上

`instanceof` 运算符的原理是基于原型链的查找。当使用 `obj instanceof Constructor` 进行判断时，`JavaScript` 引擎会从 `obj` 的原型链上查找 `Constructor.prototype` 是否存在，如果存在则返回 `true`，否则继续在原型链上查找。如果查找到原型链的顶端仍然没有找到，则返回 `false`。

`instanceof`运算符只能用于检查某个对象是否是某个构造函数的实例，不能用于基本类型的检查，如`string`、`number`等

## 判断数组的方式有哪些
-   通过原型链做判断

    ```
    obj.__proto__ === Array.prototype;
    ```

-   通过ES6的`Array.isArray()`做判断

    ```
    Array.isArrray(obj);
    ```

-   通过`instanceof`做判断

    ```
    obj instanceof Array
    ```

## 对类数组对象的理解，如何转化为数组
类数组也叫伪数组，类数组和数组类似，但不能调用数组方法，常见的类数组有arguments、通过document.getElements获取到的内容等，这些类数组具有length属性。

-   通过 `call` 调用数组的 `slice` 方法来实现转换

    ```
    Array.prototype.slice.call(arrayLike)
    ```

-   通过 `call` 调用数组的 `splice` 方法来实现转换

    ```
    Array.prototype.splice.call(arrayLike, 0)
    ```

-   通过 `apply` 调用数组的 `concat` 方法来实现转换

    ```
    Array.prototype.concat.apply([], arrayLike)
    ```

-   通过 `Array.from` 方法来实现转换

    ```
    Array.from(arrayLike)
    ```
-   通过 `...` 操作符来实现转换
    ```
    [...arrayLike]
    ```

## object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别
**都是浅拷贝**

-   `Object.assign()`方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。
-   扩展操作符`（…）`使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 `symbols` 属性。

## new操作符的实现原理
`new`操作符用来创建一个对象，并将该对象绑定到构造函数的`this`上。

new操作符的执行过程：

1.  创建一个空对象
1.  设置原型，将构造函数的原型指向空对象的 `prototype` 属性。
1.  将 `this` 指向这个对象，通过apply执行构造函数。
1.  判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象

## 什么是尾调用，使用尾调用有什么好处？

尾调用就是在函数的**最后一步调用函数**，在一个函数里调用另外一个函数会**保留当前执行的上下文**，如果在函数尾部调用，因为已经是函数最后一步，所以这时可以不用保留当前的执行上下文，**从而节省内存**。但是ES6的尾调用只能在**严格模式下开启**，正常模式是无效的。

## 设计模式
-   **单例模式**：保证类只有一个实例，并提供一个访问它的全局访问点。

-   **工厂模式**：用来创建对象，根据不同的参数返回不同的对象实例。

-   **观察者模式**：定义了对象间一种一对多关系，当目标对象状态发生改变时，所有依赖它对对象都会得到通知。 (vue的响应式)

-   **发布订阅模式**： 基于一个主题/事件通道，希望接收通知的对象通过自定义事件订阅主题，被激活事件的对象（通过发布主题事件的方式被通知)。 (event emiter)

-   **策略模式**：定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

-   **装饰器模式**：在不改变对象原型的基础上，对其进行包装扩展。


## 箭头函数与普通函数的区别
-   箭头函数是**匿名函数**，箭头函数没有`prototype`, 不能作为构造函数，使用`new`关键字。

-   箭头函数没有`arguments`

-   箭头函数没有自己的`this`，会获取所在的上下文作为自己的`this`

-   `call()`、`applay()`、`bind()`方法不能改变箭头函数中的`this`指向

-   箭头函数不能用作`Generator`函数，不能使用`yeild`关键字

## map和Object的区别
`map`和`Object`都是用键值对来存储数据，区别如下：

-   **键的类型**：`Map` 的键可以是**任意数据类型**（包括对象、函数、` NaN  `等），而 `Object` 的键**只能是字符串**或者 `Symbol` 类型。
-   **键值对的顺序**：`Map`中的键值对是按照插入的顺序存储的，而对象中的键值对则没有顺序。
-   **键值对的遍例**：`Map` 的键值对可以使用 `for...of` 进行遍历，而 `Object` 的键值对需要手动遍历键值对。
-   **继承关系**：` Map  `没有继承关系，而 `Object` 是所有对象的基类。
-   **属性污染**: `Object`存在属性污染, `Map`没有, 比如直接使用`obj['valueOf']`可以拿到原型链中的方法.

## map和weakMap的区别
-   `map`的键可以是任意类型，`weakMap`键只能是对象类型。

-   `map` 使用常规的引用来管理键和值之间的关系，因此即使键不再使用，`map` 仍然会保留该键的内存。`weakMap` 使用弱引用来管理键和值之间的关系，因此如果键不再有其他引用，垃圾回收机制可以自动回收键值对。
-   `weakMap` 不能通过for of的这种方式遍历

## 对async/await 的理解

`async/await`其实**是Generator 的语法糖**，它能实现的效果都能用`then`链来实现，它是为优化`then`链而开发出来的。通过`async`关键字声明一个异步函数， ` await  `用于等待一个异步方法执行完成，**并且会阻塞执行**。 `async` 函数**返回的是一个 Promise 对象**，如果在函数中 `return` 一个变量，`async` 会把这个直接量通过 `Promise.resolve()` 封装成 `Promise` 对象。如果没有返回值，返回 `Promise.resolve(undefined)`

## Q:什么是尾递归？

先给面试官简单说下什么是递归函数：函数内部循环调用自身的就是递归函数，若函数没有执行完毕，执行栈中会一直保持函数相关的变量，一直占用内存，当递归次数过大的时候，就可能会出现内存溢出，也叫爆栈，页面可能会卡死。

所以为了避免出现这种情况，可以采用尾递归。

尾递归：在函数的最后一步是调用函数，进入下一个函数不在需要上一个函数的环境了，内存空间 O(n) 到 O(1) 的优化 ，这就是尾递归。

尾递归的好处：可以释放外层函数的调用栈，较少栈层级，节省内存开销，避免内存溢出。
## Q:谈谈作用域链机制

先说下作用域的这个概念，作用域就是变量和函数的可访问范围，控制这个变量或者函数可访问行和生命周期（这个很重要）。

在 js 中是词法作用域，意思就是你的变量函数的作用域是由你的编码中的位置决定的，当然可以通过 apply bind 等函数进行修改。

在 ES6 之前，js 中的作用域分为两种：函数作用域和全局作用域。

全局作用域顾名思义，浏览器下就是 window ，作用域链的顶级就是它，那么只要不是被函数包裹的变量或者函数，它的作用域就是全局。

而函数作用域，就是在函数的体内声明的变量、函数及函数的参数，它们的作用域都是在这个函数内部。

那么函数中的未在该函数内定义的变量呢？这个变量怎么获取呢？这就是作用域链的概念了。

我们知道函数在执行时是有个执行栈，在函数执行的时候会创建执行环境，也就是执行上下文，在上下文中有个大对象，保存执行环境定义的变量和函数，在使用变量的时候，就会访问这个大对象，这个对象会随着函数的调用而创建，函数执行结束出栈而销毁，那么这些大对象组成一个链，就是作用域链。

那么函数内部未定义的变量，就会顺着作用域链向上查找，一直找到同名的属性。