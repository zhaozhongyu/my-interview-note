# Webpack用于构建Javascript模块脚本来给浏览器使用的前端工具。

# webpack的构建流程

1.  **初始化参数**：从配置文件或者shell语句中读取合并参数
1.  **开始编译**：用参数初始化`Compiler`对象，加载所有配置的插件，执行run方法。
1.  **确定入口**：根据`entry`参数找到入口文件
1.  **编译模块**：从⼊⼝⽂件出发，调⽤所有配置的 `Loader` 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理；
1.  **完成模块编译**：在经过第4步使⽤ `Loader` 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；
1.  **输出资源**：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 `Chunk`，再把每个 `Chunk` 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会；
1.  **输出完成**：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统

总结就是三个阶段：

-   **初始化**：启动构建，读取与合并配置参数，加载 `Plugin`，实例化 `Compiler`
-   **编译**：从 `Entry` 出发，针对每个 `Module` 串行调用对应的 `Loader` 去翻译文件的内容，再找到该 `Module` 依赖的 `Module`，递归地进行编译处理
-   **输出**：将编译后的 `Module` 组合成 `Chunk`，将 `Chunk` 转换成文件，输出到文件系统中

# 什么是Webpack的热更新（Hot Module Replacement）？原理是什么？

Webpack的热更新（Hot Module Replacement，简称HMR），**在不刷新页面的前提下，将新代码替换掉旧代码**。

`HRM的`原理实际上是 `webpack-dev-server（WDS）`和浏览器之间维护了一个`websocket`服务。当本地资源发生变化后，`webpack`会先将打包生成新的模块代码放入内存中，然后`WDS`向浏览器推送更新，并附带上构建时的hash，让客户端和上一次资源进行对比。客户端对比出差异后会向`WDS`发起`Ajax`请求获取到更改后的内容（文件列表、hash），通过这些信息再向`WDS`发起`jsonp`请求获取到最新的模块代码。

# bundle，chunk，module是什么？

-   **bundle** 捆绑包： 它是构建过程的最终产物，由说有需要的`chunk`和`module`组成。
-   **chunk** 代码块：一个`chunk`由多个模块组合而成，用于代码的合并和分割，在构建过程中一起被打包到一个文件中。
-   **module** 模块：是代码的基本单位，可以是一个文件、一个组件、一个库等。在编译的时候会从`entry`中递归寻找出所有依赖的模块。

# 什么是Code Splitting？

`Code Splitting`代码分割，是一种优化技术。它允许将一个大的`chunk`拆分成多个小的`chunk`，从而实现按需加载，减少初始加载时间，并提高应用程序的性能。

通常`Webopack`会将所有代码打包到一个单独的`bundle`中，然后在页面加载时一次性加载整个`bundle`。这样的做法可能导致初始加载时间过长，尤其是在大型应用程序中，因为用户需要等待所有代码加载完成才能访问应用程序。

`Code Splitting` 解决了这个问题，它将应用程序的代码划分为多个代码块，每个代码块代表不同的功能或路由。这些代码块可以在需要时被动态加载，使得页面只加载当前所需的功能，而不必等待整个应用程序的所有代码加载完毕。

在`Webpack`中通过`optimization.splitChunks`配置项来开启代码分割。

# Webpack的Source Map是什么？如何配置生成Source Map？

`Source Map`是一种文件，它建立了构建后的代码与原始源代码之间的映射关系。通常在开发阶段开启，用来调试代码，帮助找到代码问题所在。

可以在`Webpack`配置文件中的`devtool`选项中指定`devtool: 'source-map'`来开启。

# Webpack的Tree Shaking原理

` Tree Shaking  `也叫摇树优化，是一种通过移除多于代码，从而减小最终生成的代码体积，**生产环境默认开启**。

原理：

-   **ES6 模块系统**：`Tree Shaking`的基础是ES6模块系统，它具有静态特性，意味着模块的导入和导出关系在编译时就已经确定，不会受到程序运行时的影响。
-   **静态分析**：在`Webpack`构建过程中，`Webpack`会通过静态分析依赖图，从入口文件开始，逐级追踪每个模块的依赖关系，以及模块之间的导入和导出关系。
-   **标记未使用代码**： 在分析模块依赖时，`Webpack`会标记每个变量、函数、类和导入，以确定它们是否被实际使用。如果一个导入的模块只是被导入而没有被使用，或者某个模块的部分代码没有被使用，`Webpack`会将这些未使用的部分标记为`"unused"`。
-   **删除未使用代码**: 在代码标记为未使用后，`Webpack`会在最终的代码生成阶段，通过工具（如`UglifyJS`等）删除这些未使用的代码。这包括未使用的模块、函数、变量和导入。

# 如何提高webpack的打包速度

-   **利用缓存**：利用`Webpack`的持久缓存功能，避免重复构建没有变化的代码。可以使用cache: true选项启用缓存。
-   **使用多进程/多线程构建** ：使用`thread-loader`、`happypack`等插件可以将构建过程分解为多个进程或线程，从而利用多核处理器加速构建。
-   **使用DllPlugin和HardSourceWebpackPlugin**： `DllPlugin`可以将第三方库预先打包成单独的文件，减少构建时间。`HardSourceWebpackPlugin`可以缓存中间文件，加速后续构建过程。
-   **使用Tree Shaking**: 配置`Webpack`的`Tree Shaking`机制，去除未使用的代码，减小生成的文件体积
-   **移除不必要的插件**: 移除不必要的插件和配置，避免不必要的复杂性和性能开销。

# 如何减少打包后的代码体积

-   **代码分割（Code Splitting）** ：将应用程序的代码划分为多个代码块，按需加载。这可以减小初始加载的体积，使页面更快加载。
-   **Tree Shaking**：配置`Webpack`的`Tree Shaking`机制，去除未使用的代码。这可以从模块中移除那些在项目中没有被引用到的部分。
-   **压缩代码**：使用工具如`UglifyJS`或`Terser`来压缩`JavaScript`代码。这会删除空格、注释和不必要的代码，减小文件体积。
-   **使用生产模式**：在`Webpack`中使用生产模式，通过设置`mode: 'production'`来启用优化。这会自动应用一系列性能优化策略，包括代码压缩和`Tree Shaking`。
-   **使用压缩工具**：使用现代的压缩工具，如`Brotli`和`Gzip`，来对静态资源进行压缩，从而减小传输体积。
-   **利用CDN加速**：将项目中引用的静态资源路径修改为CDN上的路径，减少图片、字体等静态资源等打包。

# vite比webpack快在哪里

他们都是前端构建工具，但`vite`构建速度相对于`webpack`还是有一些速度优势

-   **冷启动速度**：`vite`是利用浏览器的原生`ES moudle`，采用按需加载的当时，而不是将整个项目打包。而`webpack`是将整个项目打包成一个或多个`bundle`，构建过程复杂。
-   **HMR热更新**： `vite`使用浏览器内置的`ES`模块功能，使得在开发模式下的热模块替换更加高效，那个文件更新就加载那个文件。它通过`WebSocket`在模块级别上进行实时更新，而不是像`Webpack`那样在热更新时重新加载整个包。
-   **构建速度**： 在生产环境下，`Vite`的构建速度也通常比`Webpack`快，因为`Vite`的按需加载策略避免了将所有代码打包到一个大文件中。而且，`Vite`对于缓存、预构建等方面的优化也有助于减少构建时间。
-   **缓存策略**： `Vite`利用浏览器的缓存机制，将依赖的模块存储在浏览器中，避免重复加载。这使得页面之间的切换更加迅速。
-   **不需要预编译**： `Vite`不需要预编译或生成中间文件，因此不会产生大量的临时文件，减少了文件IO操作，进一步提升了速度。