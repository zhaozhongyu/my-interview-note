## XSS（跨站脚本攻击）
`XSS` 攻击指的是跨站脚本攻击，是一种**代码注入攻击**。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 `cookie` 等。
**避免方式**

-   不直接拼接代码执行。
-   对一些敏感信息进行保护，比如 `cookie` 使用 `http-only`，使得脚本无法获取。
-   对用户输入的地方和变量都需要仔细检查长度和对 ` ”<”,”>”,”;”,”’”  `等字符做过滤
## CSRF（跨站请求伪造）

`CSRF` 攻击的本质是利用 `cookie` 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

**避免方式**

-   添加验证码验证
-   使用`token`验证
-   限制 `cookie` 不能作为被第三方使用
-   进行同源检测

# 什么进程和线程？有什么区别
## 进程（Process）

进程是计算机中正在运行的程序的实例，**一个进程就是一个程序运行实例**。它拥有独立的内存空间、代码和数据，并且由操作系统负责调度和管理。**每个进程在执行时都会分配独立的内存空间，不同进程之间的内存是隔离的，一个进程的错误不会直接影响其他进程。** 进程之间通过进程间通信（IPC）机制来交换数据和进行通信，常见的`IPC`方式包括管道、消息队列、共享内存等。进程的切换开销较大，因为需要保存和恢复进程的完整状态，涉及到内存保护和虚拟内存的切换。

## 线程（Thread）

**线程是进程的子任务，一个进程可以包含多个线程**。它们共享相同的代码和数据，但拥有独立的执行栈和寄存器集合。**多个线程可以在同一进程内并发执行**，共享进程的资源，如内存空间、打开的文件等。线程间的通信和数据交换比进程间的通信更加方便，因为它们共享相同的地址空间。线程的切换开销较小，因为线程共享进程的地址空间，切换时不需要切换内存页表，速度较快。

## 区别

-   进程和线程都可以实现并发执行，但进程是独立的执行实体，而**线程是依赖于进程的**。
-   进程之间资源相互隔离，**线程共享所属进程的资源**。
-   创建和销毁线程的开销较小，而创建和销毁进程的开销较大。
-   多线程程序的编程复杂度通常比单线程程序高，但多线程可以更好地利用多核处理器来提高程序的执行效率。
## 浏览器有哪些进程

-   **主进程**：负责处理用户输入、渲染页面等主要任务。
-   **渲染进程**：渲染进程负责解析`HTML`、`CSS`和`JavaScript`，并将网页渲染成可视化内容。
-   **GPU进程**：负责处理浏览器中的`GPU`加速任务。
-   **网络线程**：网络进程负责处理浏览器中的网络请求和响应，包括下载网页和资源等。
-   **插件进程**：负责浏览器插件运行。 ![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d9ff0694164b48a5a3c975875af06730~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=750&h=324&s=13992&e=webp&b=fefdfd)

# 协商缓存和强缓存的区别

## 强缓存

使用强缓存策略时，如果缓存资源有效，浏览器会**从本地读取缓存资源并返回200**，不必再向服务器发起请求。强缓存策略可以通过两种方式来设置，分别是 `http` 头信息中的 `Expires` 属性和 `Cache-Control` 属性。

**Expires指定资源的过期时间**。在过期时间以内，改资源可以被缓存使用，不需要向浏览器发送请求。这个时间依赖于服务器时间，会存在服务器时间和客户端时间不一致。

**Cache-Control属性：**

-   `private`： 仅浏览器可以缓存
-   `public`：浏览器和代理服务器都可以缓存
-   `max-age=xxx` 过期时间，单位为秒
-   `no-cache` 不进行强缓存，但会有协商缓存
-   `no-store`不强缓存，也不协商缓存

当两种方式一起使用时，**Cache-Control 的优先级要高于 Expires**。
## 协商缓存

如果设置强缓存，无需发起请求，直接使用缓存内容。如果没有命中强缓存，设置了协商缓存，也不需要发起请求，使用缓存。

命中协商缓存条件：
-   `Etag`
-   `Last-Modified`, 标记的时间只能精确到1秒

在使用协商缓存时，**会先向服务器发送一个请求，如果资源没有发生修改，则请求返回304状态**，让浏览器使用本地缓存。如果资源发生修改，则返回修改后的内容

在`request headers`中的`Etag`属性和`Last-Modified`属性，来进行设置。其中，**ETage优先于Last-Modified**。

**Etag文件改动** 服务器在返回资源的时候，在头信息中添加`Etag`属性，这个属性是资源的唯一标识符。当资源改变，这个值也会改变。下次请求资源时，会在请求头中添加`If-None-Match`属性，为上一次请求的资源的`Etag`值。服务端会通过这个属性和资源最后一次修改时间进行对比，以此来判断资源是否修改。这种方式比`Last-Modified`更加准确。

**Last-Modified 上次修改时间** 服务器通过在响应头上添加`Last-Modified`属性，来指出资源**最后一次修改时间**。当浏览器发起请求时，会在请求头上添加一个`IF-Modified-Since`属性，值为上一次资源请求的`Last-Modified`的值。服务区会通过这个属性和最后修改时间来进行比较，以此来判断资源是否修改。如果没有资源修改，返回`304`状态，使用本地缓存。如果资源修改，就返回最新资源，`200`状态。

这种方式有个缺点，`Last-Modified`标记的时间只能精确到1秒，如果文件在1秒内修改，但是 `Last-Modified` 却没有改变，这样会造成缓存命中的不准确。

**区别**
-   强缓存优先级高于协商缓存
-   协商缓存不论命中与否都会发送一次请求
-   强缓存返回`200`，协商缓存命中返回`304`
-   `Ctrl+F5` 会强制刷新会跳过所有缓存，而F5刷新跳过强缓存，但是会检查协商缓存。

## 为什么需要浏览器缓存？

使用浏览器缓存，有以下优点：

-   减少了服务器的负担，提高了网站的性能
-   加快了客户端网页的加载速度
-   减少了多余网络数据传输

# 浏览器的渲染过程
-   解析文档，生成`DOM`树
-   解析`CSS`，根据`CSS`规则生成`CSSOM`规则树
-   在`CSSOM`树和`DOM`树生成完后，合并`DOM`、`CSSO`M树构建渲染树
-   渲染树构建完成后，开始计算元素大小和位置【回流发生在这个阶段】
-   根据计算好的位置信息将内容渲染到屏幕上【重绘发生在这个阶段】

# 浏览器渲染优化

-   优化`javaScript`，`JavaScript`会阻塞HTML的解析，改变`JavaScrip`加载方式。

    -   将`JavaScript`放到`body`最后面
    -   尽量使用异步加载`JS`资源，这样不会阻塞`DOM`解析，如[defer、async](https://juejin.cn/post/7269794410573512758#heading-8 "https://juejin.cn/post/7269794410573512758#heading-8")

-   优化CSS加载，

    -   CSS样式少，使用内嵌样式
    -   导入外部样式使用`link`，而不是`@import`，因为它会阻塞渲染。

-   减少回流重绘

    -   避免频繁操作样式
    -   避免频繁操作DOM
    -   复杂动画使用定位脱离文当流
    -   使用`transform`替代动画
# 回流与重绘

**回流**当DOM变化影响了元素，比如元素的尺寸、布局、显示隐藏等改变了，需要重写构建。每个页面至少需要一次回流，就是在页面第一次加载的时候，这个时候一定会发生回流。

**重绘**当一个元素的外观发生变化，但是没有改变布局，重新渲染元素的外观。比如`background-color`、`color`
**如何避免回流重绘：**

-   避免使用`table`布局
-   尽可能在`DOM`树的最末端改变`class`
-   不要频繁的操作元素的样式
-   避免设置多层内联样式
-   开启GPU加速
-   使用`absolute`或者`fixed`，脱离标准文档流
-   构建BFC块级格式上下文.
**回流必将引起重绘，而重绘不一定会引起回流**