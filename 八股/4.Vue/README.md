## MVVM的理解

`MVVM`是一种软件架构模式，`MVVM` 分为 `Model`、`View`、`ViewModel`：

-   `Model`代表数据模型，数据和业务逻辑都在`Model`层中定义；
-   `View`代表UI视图，负责数据的展示；
-   `ViewModel`负责监听`Model`中数据的改变并且控制视图的更新，处理用户交互操作；

`Model`和`View`并无直接关联，而是通过`ViewModel`来进行联系的，`Model`和`ViewModel`之间有着双向数据绑定的联系。因此当`Model`中的数据改变时会触发`View`层的刷新，`View`中由于用户交互操作而改变的数据也会在`Model`中同步。



## Vue2和Vue3有哪些区别

-   `Vue2`使用的是` optionsAPI  `，`Vue3`使用`composition API`，更好的组织代码，提高代码可维护性
-   `Vue3`使用`Proxy`代理实现了新的响应式系统，比`Vue2`有着更好的性能和更准确的数据变化追踪能力。
-   `Vue3`引入了Teleprot组件，可以将DOM元素渲染到DOM数的其他位置，用于创建模态框、弹出框等。
-   `Vue3`全局API名称发生了变化，同时新增了`watchEffect`、`Hooks`等功能
-   `Vue3`对`TypeScript`的支持更加友好
-   `Vue3`核心库的依赖更少，减少打包体积
-   3支持更好的`Tree Shanking`，可以更加精确的按需要引入模块

## SPA和多页面有什么区别

**区别**

-   **页面加载方式**：在多页面应用中，每个页面都是独立的 HTML 文件，每次导航时需要重新加载整个页面。而在 `SPA` 中，初始加载时只加载一个 HTML 页面，后续的导航通过 `JavaScript` 动态地更新页面内容，无需重新加载整个页面。
-   **用户体验**：`SPA` 提供了流畅、快速的用户体验，因为页面切换时无需等待整个页面的重新加载，只有需要的数据和资源会被加载，减少了页面刷新的延迟。多页面应用则可能会有页面刷新的延迟，给用户带来较长的等待时间。
-   **代码复用**：`SPA` 通常采用组件化开发的方式，可以在不同的页面中复用组件，提高代码的可维护性和可扩展性。多页面应用的每个页面都是独立的，组件复用的机会较少。
-   **路由管理**：在多页面应用中，页面之间的导航和路由由服务器处理，每个页面对应一个不同的 `URL`。而在 `SPA` 中，前端负责管理页面的导航和路由，通过前端路由库（如 `React Router` 或 `Vue Router`）来管理不同路径对应的组件。
-   **SEO（搜索引擎优化）** ：由于多页面应用的每个页面都是独立的 HTML 文件，搜索引擎可以直接索引和抓取每个页面的内容，有利于搜索引擎优化。相比之下，`SPA` 的内容是通过 `JavaScript` 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容，需要采取额外的优化措施。
-   服务器负载：`SPA` 只需初始加载时获取 `HTML`、`CSS` 和 `JavaScript` 文件，后续的页面更新和数据获取通常通过 API 请求完成，减轻了服务器的负载。而多页面应用每次导航都需要从服务器获取整个页面的内容。

**优点**

-   **用户体验**：`SPA` 提供了流畅、快速的用户体验，在页面加载后，只有需要的数据和资源会被加载，减少了页面刷新的延迟。
-   **响应式交互**：由于 `SPA` 依赖于异步数据加载和前端路由，可以实现实时更新和动态加载内容，使用户可以快速地与应用程序交互。
-   **代码复用**：`SPA` 通常采用组件化开发的方式，提高了代码的可维护性和可扩展性。
-   **服务器负载较低**：由于只有初始页面加载时需要从服务器获取 `HTML`、`CSS` 和 `JavaScript` 文件，减轻了服务器的负载。

**缺点**：

-   **首次加载时间**：`SPA` 首次加载时需要下载较大的 `JavaScript` 文件，这可能导致初始加载时间较长。
-   **SEO（搜索引擎优化）问题**：由于 `SPA` 的内容是通过 `JavaScript` 动态生成的，搜索引擎的爬虫可能无法正确地获取和索引页面的内容。
-   **内存占用**：`SPA` 在用户浏览应用程序时保持单个页面的状态，这可能导致较高的内存占用。
-   **安全性**：由于 `SPA` 通常使用 `API` 进行数据获取，因此需要特别注意安全性。

## Vue的性能优化有哪些

### 编码阶段

-   `v-if`和`v-for`不一起使用
-   `v-for`保证`key`的唯一性
-   使用`keep-alive`缓存组件
-   `v-if`和`v-show`酌情使用
-   路由懒加载、异步组件
-   图片懒加载
-   节流防抖
-   第三方模块按需引入
-   服务端与渲染

### 打包优化

-   压缩代码
-   使用CDN加载第三方模块
-   抽离公共文件

### 用户体验

-   骨架屏
-   客户端缓存

### SEO优化

-   预渲染
-   服务端渲染
-   合理使用 `meta` 标签

## Vue生命周期

**创建前后：**

-   `beforeCreate（创建前）：` 数据观测和初始化事件还未开始，不能访问`data`、`computed`、`watch`、`methods`上的数据方法。
-   `created(创建后)：`实例创建完成，可以访问`data`、`computed`、`watch`、`methods`上的数据方法，但此时渲染节点还未挂在到DOM上，所以不能访问。

**挂载前后：**

-   `beforeMount（挂载前）:` Vue实例还未挂在到页面HTML上，此时可以发起服务器请求
-   `mounted（挂载后）:`Vue实例已经挂在完毕，可以操作DOM

**更新前后：**

-   `beforeUpdate（更新前）:` 数据更新之前调用，还未渲染页面
-   `updated（更新后）:`DOM重新渲染，此时数据和界面都是新的。

**销毁前后：**

-   `beforeDestorye（销毁前）:`实例销毁前调用，这时候能够获取到`this`
-   `destoryed（销毁后）:`实例销毁后调用，实例完全被销毁。

## Computed 和 Watch 的区别

`computed`计算属性，通过对已有的属性值进行计算得到一个新值。它需要依赖于其他的数据，当数据发生变化时，`computed`会自动计算更新。`computed`属性值会被缓存，只有当依赖数据发生变化时才会重新计算，这样可以避免重复计算提高性能。

`watch`用于监听数据的变化，并在变化时执行一些操作。它可以监听单个数据或者数组，当数据发生变化时会执行对应的回调函数，和`computed`不同的是`watch`不会有缓存。

## Vue是如何收集依赖的？

依赖收集发生在`defineReactive()`方法中，在方法内`new Dep()`实例化一个`Dep()`实例，然后在`getter`中通过`dep.depend()`方法对数据依赖进行收集，然后在`settter`中通过`dep.notify()`通知更新。整个`Dep`其实就是一个观察者，吧收集的依赖存储起来，在需要的时候进行调用。在收集数据依赖的时候，会为数据创建一个`Watcher`，当数据发生改变通知每个`Watcher`，由`Wathcer`进行更新渲染。

## slot是什么？有什么作用？原理是什么？

`slot`插槽，一般在封装组件的时候使用，在组件内不知道以那种形式来展示内容时，可以用`slot`来占据位置，最终展示形式由父组件以内容形式传递过来，主要分为三种：

-   **默认插槽**：又名匿名插槽，当`slot`没有指定`name`属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。
-   **具名插槽**：带有具体名字的插槽，也就是带有`name`属性的`slot`，一个组件可以出现多个具名插槽。
-   **作用域插槽**：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。

实现原理：当子组件`vm`实例化时，获取到父组件传入的`slot`标签的内容，存放在`vm.$slot`中，默认插槽为`vm.$slot.default`，具名插槽为`vm.$slot.xxx`，xxx 为插槽名，当组件执行渲染函数时候，遇到`slot`标签，使用`$slot`中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。

## Vue模版编译原理

模版编译主要过程：`template ---> ast ---> render`，分别对象三个方法

-   `parse` 函数解析 `template`
-   `optimize` 函数优化静态内容
-   `generate` 函数创建 `render` 函数字符串

调用`parse`方法，将`template`转化为`AST`（抽象语法树），`AST`定义了三种类型，一种`html`标签，一种文本，一种插值表达式，并且通过 `children` 这个字段层层嵌套形成了树状的结构。

`optimize`方法对`AST`树进行静态内容优化，分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化。

`generate`将`AST`抽象语法树编译成 `render`字符串，最后通过`new Function(render)`生成可执行的`render`函数

## 对虚拟DOM的理解

虚拟DOM就是用JS对象来表述DOM节点，是对真实DOM的一层抽象。可以通过一些列操作使这个棵树映射到真实DOM上。

如在`Vue`中，会把代码转换为虚拟DOM，在最终渲染到页面，在每次数据发生变化前，都会缓存一份虚拟DOM，通过`diff`算法来对比新旧虚拟DOM记录到一个对象中按需更新，最后创建真实DOM，从而提升页面渲染性能。

## 虚拟DOM就一定比真实DOM更快吗

**虚拟DOM不一定比真实DOM更快，而是在特定情况下可以提供更好的性能。**

在复杂情况下，虚拟DOM可以比真实DOM操作更快，因为它是在内存中维护一个虚拟的DOM树，将真实DOM操作转换为对虚拟DOM的操作，然后通过`diff`算法找出需要更新的部分，最后只变更这部分到真实DOM就可以。在频繁变更下，它可以批量处理这些变化从而减少对真实DOM的访问和操作，减少浏览器的回流重绘，提高页面渲染性能。

而在一下简单场景下，直接操作真实DOM可能会更快，当更新操作很少或者只是局部改变时，直接操作真实DOM比操作虚拟DOM更高效，省去了虚拟DOM的计算、对比开销。

## 虚拟DOM的解析过程

-   首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 `TagName`、`props` 和 `Children` 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。
-   当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。
-   最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。

