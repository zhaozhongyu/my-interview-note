1. 闭包是什么？
闭包解决了什么问题？
为什么它还能访问到本该被销毁的变量？

> 函数B能引用到函数A的变量，函数B就是闭包
闭包缓存了上级作用域，比如Ajax成功回调，回调了整个上级作用域的访问和操作能力，更加的方便
闭包是建立在一个函数内部的子函数，由于能访问上级函数作用域的关系，即使上级函数执行完，作用域中的变量依旧存活在内存中，无法被释放。

闭包解决了什么问题
简单一点来说闭包其实，闭包解决了函数变量被外部作用域变量污染的问题（或者是全局变量污染的问题）更好地保护好一些变量，调用变量的时候效率也会更高

(function(window, undefined) { // 这里 undefined 是变量名，不是实际的undefined 类型
    var jQuery = function() {}
    // ...
    window.jQuery = window.$ = jQuery;
})(window);
从上面的代码可看出，自动初始化这个函数，让其只构建一次。详细说一下这种写法的优势： 

window和undefined都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些
undefined也是同样的道理，其实这个undefined并不是JavaScript数据类型的undefined，而是一个普普通通的变量名。只是因为没给它传递值，它的值就是undefined，undefined并不是JavaScript的保留字段


2. 闭包
首先闭包正确的定义是：假如一个函数能访问外部的变量，那么这个函数它就是一个闭包，而不是一定要返回一个函数。这个定义很重要，下面的内容需要用到。
```
let a = 1
// fn 是闭包
function fn() {
  console.log(a);
}

function fn1() {
  let a = 1
  // 这里也是闭包
  return () => {
    console.log(a);
  }
}
const fn2 = fn1()
fn2()
```
大家都知道闭包其中一个作用是访问私有变量，就比如上述代码中的 fn2 访问到了 fn1 函数中的变量 a。但是此时 fn1 早已销毁，我们是如何访问到变量 a 的呢？不是都说原始类型是存放在栈上的么，为什么此时却没有被销毁掉？




